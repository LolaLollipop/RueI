<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Using the Scheduler | RueI </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Using the Scheduler | RueI ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Ruemena/RueI/blob/master/markdown/scheduling.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="RueI">
            RueI
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="using-the-scheduler">Using the Scheduler</h1>

<p>RueI comes with the <a href="../api/RueI.Displays.Scheduling.Scheduler">Scheduler</a>, and every display has one of them. the main purpose of the Scheduler is to provide an easy way to update the display at a certain time, and to provide a way to batch updates together to prevent getting ratelimited.</p>
<p>normally, the hints system comes with a 0.5 second ratelimit. if you send a hint (which updating the display does), you cannot send another one for 0.5 seconds<a href="#asterisk">*</a>. this can easily create problems. for example, what if you update the display in 0.3 seconds and 0.5 seconds? normally, the first update would show, but then the second update would not show up until in 0.8 seconds.</p>
<p>this might not seem like the biggest problem, but it can make things look weird because of the delay. instead, what RueI will do is batch those two operations together, averaging the times. so, in that example, it will update the display in 0.4 seconds (assuming they both have the same priority).</p>
<h2 id="how-to-do-it">How to do it</h2>
<p>scheduling a job is pretty easy. first, you have to get the <a href="../api/RueI.Displays.DisplayCore">DisplayCore</a> of a player, and then access the <code>DisplayCore.Scheduler</code> property. then you can use the <code>Scheduler.Schedule</code> method to schedule jobs. here's an example:</p>
<pre><code class="lang-csharp">// assuming hub is previously defined as a ReferenceHub
SetElement element = new(300, &quot;Hello!!&quot;);
DisplayCore core = DisplayCore.Get(hub);
Display display = new(core);
core.Scheduler.Schedule(TimeSpan.FromSeconds(5), () =&gt; display.Elements.Add(element));
</code></pre>
<p>notice how you do not have to explicitly call <code>display.Update()</code> or <code>core.Update()</code>. this is because, once RueI performs a batch job, it automatically updates the display. updating the display in a batch job doesn't do anything as the DisplayCore ignores all update requests when it is performing a batch job. so, this does nothing:</p>
<pre><code class="lang-csharp">core.Scheduler.Schedule(TimeSpan.FromSeconds(5), () =&gt; core.Update());
</code></pre>
<h2 id="canceling-a-job">Canceling a job</h2>
<p>often, you're going to want to cancel a job that is ongoing. however, RueI does not return a reference to a job that you can then use to cancel it. instead, you use a <a href="../api/RueI.Displays.Scheduling.JobToken">JobToken</a>. you can then pass a JobToken in the <code>Scheduler.Schedule()</code> method. the benefit of this is that since you can declare a static JobToken singleton, you can ensure that there is only ever one instance of a certain job. here's an example:</p>
<pre><code class="lang-csharp">public static JobToken HelloToken { get; } = new();

public void UpdateDisplay(ReferenceHub hub) {
    SetElement element = new(300, &quot;Hello!!&quot;);
    DisplayCore core = DisplayCore.Get(hub);
    Display display = new(core);

    core.Scheduler.KillJob(HelloToken);
    core.Scheduler.Schedule(TimeSpan.FromSeconds(5), () =&gt; display.Elements.Add(element));
}
</code></pre>
<p>with this, you won't ever have to worry about having multiple instances of the same job.</p>
<p><a name="asterisk">* it is more complicated than this, technically. however, RueI enforces a 0.525 second ratelimit, so you won't notice it.</a></p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Ruemena/RueI/blob/master/markdown/scheduling.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
